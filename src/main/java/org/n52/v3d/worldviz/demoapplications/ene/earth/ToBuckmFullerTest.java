package org.n52.v3d.worldviz.demoapplications.ene.earth;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.List;

import org.n52.v3d.worldviz.dataaccess.load.DatasetLoader;
import org.n52.v3d.worldviz.dataaccess.load.dataset.XmlDataset;
import org.n52.v3d.worldviz.helper.RelativePaths;
import org.n52.v3d.worldviz.projections.Wgs84ToDymaxionTransform;
import org.n52.v3d.worldviz.triangulation.PolygonTriangulator;
import org.n52.v3d.worldviz.triturusextensions.VgMultiPolygon;

import org.n52.v3d.triturus.core.T3dException;
import org.n52.v3d.triturus.gisimplm.GmSimpleTINGeometry;
import org.n52.v3d.triturus.vgis.VgAttrFeature;
import org.n52.v3d.triturus.vgis.VgGeomObject;
import org.n52.v3d.triturus.vgis.VgIndexedTIN;
import org.n52.v3d.triturus.vgis.VgPoint;

public class ToBuckmFullerTest {

	private static BufferedWriter mDoc;
	private static double radiusSphere = 50;
	private static double radiusWorldBordersTINs = radiusSphere + 0.55;
	private static double radiusWorldBorders = radiusWorldBordersTINs + 0.01;
	private static String sphereTexture = "../data/color_etopo1_ice_low.jpg";
	private static String attributeName = "Access to Electricity 2000, percentage of people estimated";
	private static String dataXML = RelativePaths.ELECTRICITY_ACCESS_XML;
	private static String outputFile = "test/ElectricityAccess_dymaxion_transparency.x3d";
	private static double minValue;
	private static double maxValue;
	private static double red;
	private static double green;
	private static double blue;
	private static double transparency;
	private static double minValueForTransparency;
	private static boolean checkForMinValueForTransparency = true;

	public static void main(String[] args) throws Exception {

		XmlDataset dataset = null;

		DatasetLoader datasetLoader = new DatasetLoader(dataXML);

		try {
			dataset = datasetLoader.loadDataset();
		} catch (Exception e) {
			e.printStackTrace();
		}

		List<VgAttrFeature> features = dataset.getFeatures();

		setMinMaxForAttribute(features);

		try {
			mDoc = new BufferedWriter(new FileWriter(outputFile));

			wl("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
			wl("<!DOCTYPE X3D PUBLIC \"ISO//Web3D//DTD X3D 3.2//EN\" \"http://www.web3d.org/specifications/x3d-3.2.dtd\">");
			wl("<X3D version=\"3.2\" profile=\"Immersive\" xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='http://www.web3d.org/specifications/x3d-3.2.xsd'>");

			wl("  <Scene>");
			wl("    <WorldInfo info='Scene generated by 52N Triturus'></WorldInfo>");
			// wl("    <NavigationInfo type=\"EXAMINE\"></NavigationInfo>");
			wl("    <Background skyColor=\"1 1 1\"></Background>");

			wl("<Viewpoint description='Rear View' orientation='0 1 0 3.14159' position='0 0 -15'/>");

			// wl("      <Shape>");
			// wl("        <Appearance>");
			// // wl("          <Material emissiveColor=\"0 0 0.2" +
			// "\"></Material>");
			// wl("<Material/>");
			// wl("<ImageTexture url=\"" + sphereTexture + "\"/>");
			// wl("<TextureTransform translation='-.25 .0'/>");
			// wl("        </Appearance>");
			// wl("        <Sphere radius=\"" + radiusSphere + "\"/>");
			// wl("      </Shape>");

			for (VgAttrFeature vgAttrFeature : features) {

				VgGeomObject geometry = vgAttrFeature.getGeometry();

				VgMultiPolygon vgMultiPolygon = (VgMultiPolygon) geometry;

				drawTriangles(vgMultiPolygon, vgAttrFeature);

				// borders

				// VgMultiPolygon multiPolygon =
				// transformToBuckmFuller(vgMultiPolygon);
				//
				// for (int k = 0; k < multiPolygon.getNumberOfGeometries();
				// k++) {
				//
				// VgPolygon polygon = (VgPolygon) multiPolygon.getGeometry(k);
				//
				// wl("<Transform translation=\"0 0.001 0\">");
				//
				// wl("      <Shape>");
				// wl("        <Appearance>");
				// wl("          <Material emissiveColor=\"0 0 0\""
				// + " transparency=\"" + transparency
				// + "\"></Material>");
				// // wl("          <Material emissiveColor=\"0 0 0"
				// // + "\"></Material>");
				// wl("        </Appearance>");
				//
				// w("<IndexedLineSet coordIndex=\"");
				//
				// for (int l = 0; l < polygon.numberOfVertices(); l++) {
				// w("" + l + " ");
				// }
				//
				// wl("\">");
				//
				// w("<Coordinate point=\"");
				// for (int i = 0; i < polygon.numberOfVertices(); i++) {
				// VgPoint point = polygon.getVertex(i);
				// w("" + point.getX() + " " + point.getZ() + " "
				// + (-point.getY()) + " ");
				// }
				// wl("\"/>");
				//
				// wl("</IndexedLineSet>");
				//
				// wl("      </Shape>");
				//
				// wl("</Transform>");
				// }
			}

			wl("  </Scene>");
			wl("</X3D>");

			mDoc.close();

			System.out.println("Success!");
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	private static void setMinMaxForAttribute(List<VgAttrFeature> features) {
		double locMin = -1;
		double locMax = -1;

		for (VgAttrFeature vgAttrFeature : features) {

			double value = Double.valueOf((String) vgAttrFeature
					.getAttributeValue(attributeName));

			if (locMin == -1 && locMax == -1) {
				// erster Schritt
				locMin = value;
				locMax = value;
			} else {
				// jeder weitere Schritt
				if (value < locMin)
					locMin = value;
				else if (value > locMax)
					locMax = value;
			}

		}

		maxValue = locMax;
		minValue = locMin;

	}

	private static void drawTriangles(VgMultiPolygon multiPolygon,
			VgAttrFeature vgAttrFeature) throws Exception {

		Double attributeValue = Double.valueOf((String) vgAttrFeature
				.getAttributeValue(attributeName));
		calcColor(attributeValue);
		calcTransparency(attributeValue);

		List<VgIndexedTIN> vgTINs = PolygonTriangulator
				.triangulateMultiPolygon(multiPolygon);

		// transformiere VgTins nach Buckminster Fuller
		List<VgIndexedTIN> buckmFullerTINs = transformToBuckmFuller(vgTINs);

		for (VgIndexedTIN vgIndexedTIN : buckmFullerTINs) {

			wl("      <Shape>");
			wl("        <Appearance>");
			wl("          <Material transparency=\"" + transparency
					+ "\"></Material>");
			wl("        </Appearance>");

			w("<IndexedFaceSet solid=\"false\" colorPerVertex=\"false\" creaseAngle=\"0.5\" coordIndex=\"");

			for (int i = 0; i < vgIndexedTIN.numberOfTriangles(); i++) {
				int[] triangleVertexIndices = vgIndexedTIN
						.getTriangleVertexIndices(i);
				w("" + triangleVertexIndices[0] + " "
						+ triangleVertexIndices[1] + " "
						+ triangleVertexIndices[2] + "-1" + " ");
			}

			wl("\">");
			w("<Color color=\"");
			for (int i = 0; i < vgIndexedTIN.numberOfTriangles(); i++) {

				w("" + red + " " + green + " " + blue + " ");
			}
			wl("\"/>");

			w("<Coordinate point=\"");
			for (int i = 0; i < vgIndexedTIN.numberOfPoints(); i++) {
				VgPoint point = vgIndexedTIN.getPoint(i);
				w("" + point.getX() + " " + point.getZ() + " "
						+ (-point.getY()) + " ");
			}
			wl("\"/>");

			wl("</IndexedFaceSet>");
			wl("      </Shape>");
		}

	}

	private static List<VgIndexedTIN> transformToBuckmFuller(
			List<VgIndexedTIN> vgTINs) throws Exception {
		for (VgIndexedTIN vgIndexedTIN : vgTINs) {

			if (vgIndexedTIN instanceof GmSimpleTINGeometry) {

				GmSimpleTINGeometry tin = (GmSimpleTINGeometry) vgIndexedTIN;

				for (int i = 0; i < tin.numberOfPoints(); i++) {
					VgPoint oldPoint = tin.getPoint(i);

					VgPoint newPointBuckmFuller = Wgs84ToDymaxionTransform
							.transformToBuckmFuller(oldPoint);

					tin.setPoint(i, newPointBuckmFuller);

				}

			}

		}
		return vgTINs;
	}

	private static void calcColor(double attributeValue) {

		red = ((attributeValue - minValue) / (maxValue - minValue)) * 1;
		// green = 1 - red;
		green = 0;
		blue = 0;

	}

	private static void calcTransparency(Double attributeValue) {

		transparency = 1 - (((attributeValue - minValue) / (maxValue - minValue)) * 1);

		if (checkForMinValueForTransparency) {
			if (transparency < minValueForTransparency)
				transparency = minValueForTransparency;
		}

	}

	private static void w(String pLine) {
		try {
			mDoc.write(pLine);
		} catch (IOException e) {
			throw new T3dException(e.getMessage());
		}
	}

	private static void wl(String pLine) {
		try {
			mDoc.write(pLine);
			mDoc.newLine();
		} catch (IOException e) {
			throw new T3dException(e.getMessage());
		}
	}

	private static void wl() {
		try {
			mDoc.newLine();
		} catch (IOException e) {
			throw new T3dException(e.getMessage());
		}
	}
}
